/******************************************************************************

  LLDP Agent Daemon (LLDPAD) Software
  Copyright(c) 2012 IBM Corp.
  Copyright(c) 2012 Intel Corporation.

  Author(s): John Fastabend <john.r.fastabend at intel.com>
  Author(s): Mijo Safradin <mijo at linux.vnet.ibm.com>

  This program is free software; you can redistribute it and/or modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.

  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.

  You should have received a copy of the GNU General Public License along with
  this program; if not, write to the Free Software Foundation, Inc.,
  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.

  The full GNU General Public License is included in this distribution in
  the file called "COPYING".

  Contact Information:
  open-lldp Mailing List <lldp-devel at open-lldp.org>

  Note: this file originally auto-generated by mib2c using
        version : 5.7.1
******************************************************************************/

#include "snmp/snmp_agent.h"

int ieee8021_evb_sys_type = -1;
int ieee8021BridgeEvbSysNumExternalPorts = -1;
int ieee8021BridgeEvbSysEvbLldpTxEnable = -1;
int ieee8021BridgeEvbSysEvbLldpManual = -1;
int ieee8021BridgeEvbSysEvbLldpGidCapable = -1;
int ieee8021BridgeEvbECPACkTimer = ECP_ACK_TIMER_DEFAULT;
int ieee8021BridgeEvbECPMaxRetires = ECP_MAX_RETRIES;
int ieee8021BridgeEvbSysVdpDfltRsrcWaitDelay = VDP_ACK_TIMER_DEFAULT;
int ieee8021BridgeEvbSysVdpDfltReinitKeepAlive = VDP_KEEPALIVE_TIMER_DEFAULT;

/** Initializes the ieee8021BridgeEvbSys module */
void init_ieee8021BridgeEvbSys(void)
{
	const oid ieee8021BridgeEvbSysType_oid[] = { 1,3,111,2,802,1,1,24,1,1,1 };
	const oid ieee8021BridgeEvbSysNumExternalPorts_oid[] = { 1,3,111,2,802,1,1,24,1,1,2 };
	const oid ieee8021BridgeEvbSysEvbLldpTxEnable_oid[] = { 1,3,111,2,802,1,1,24,1,1,3 };
	const oid ieee8021BridgeEvbSysEvbLldpManual_oid[] = { 1,3,111,2,802,1,1,24,1,1,4 };
	const oid ieee8021BridgeEvbSysEvbLldpGidCapable_oid[] = { 1,3,111,2,802,1,1,24,1,1,5 };
	const oid ieee8021BridgeEvbSysEcpAckTimer_oid[] = { 1,3,111,2,802,1,1,24,1,1,6 };
	const oid ieee8021BridgeEvbSysEcpMaxRetries_oid[] = { 1,3,111,2,802,1,1,24,1,1,7 };
	const oid ieee8021BridgeEvbSysVdpDfltRsrcWaitDelay_oid[] = { 1,3,111,2,802,1,1,24,1,1,8 };
	const oid ieee8021BridgeEvbSysVdpDfltReinitKeepAlive_oid[] = { 1,3,111,2,802,1,1,24,1,1,9 };

	DEBUGMSGTL(("ieee8021BridgeEvbSys", "Initializing\n"));

	netsnmp_register_scalar(
		netsnmp_create_handler_registration(
			"ieee8021BridgeEvbSysType",
			handle_ieee8021BridgeEvbSysType,
			ieee8021BridgeEvbSysType_oid,
			OID_LENGTH(ieee8021BridgeEvbSysType_oid),
			HANDLER_CAN_RONLY));

	netsnmp_register_scalar(
		netsnmp_create_handler_registration(
			"ieee8021BridgeEvbSysNumExternalPorts",
			handle_ieee8021BridgeEvbSysNumExternalPorts,
			ieee8021BridgeEvbSysNumExternalPorts_oid,
			OID_LENGTH(ieee8021BridgeEvbSysNumExternalPorts_oid),
			HANDLER_CAN_RONLY));

	netsnmp_register_scalar(
		netsnmp_create_handler_registration(
			"ieee8021BridgeEvbSysEvbLldpTxEnable",
			handle_ieee8021BridgeEvbSysEvbLldpTxEnable,
			ieee8021BridgeEvbSysEvbLldpTxEnable_oid,
			OID_LENGTH(ieee8021BridgeEvbSysEvbLldpTxEnable_oid),
			HANDLER_CAN_RWRITE));

	netsnmp_register_scalar(
		netsnmp_create_handler_registration(
			"ieee8021BridgeEvbSysEvbLldpManual",
			handle_ieee8021BridgeEvbSysEvbLldpManual,
			ieee8021BridgeEvbSysEvbLldpManual_oid,
			OID_LENGTH(ieee8021BridgeEvbSysEvbLldpManual_oid),
			HANDLER_CAN_RWRITE));

	netsnmp_register_scalar(
		netsnmp_create_handler_registration(
			"ieee8021BridgeEvbSysEvbLldpGidCapable",
			handle_ieee8021BridgeEvbSysEvbLldpGidCapable,
			ieee8021BridgeEvbSysEvbLldpGidCapable_oid,
			OID_LENGTH(ieee8021BridgeEvbSysEvbLldpGidCapable_oid),
			HANDLER_CAN_RWRITE));

	netsnmp_register_scalar(
		netsnmp_create_handler_registration(
			"ieee8021BridgeEvbSysEcpAckTimer",
			handle_ieee8021BridgeEvbSysEcpAckTimer,
			ieee8021BridgeEvbSysEcpAckTimer_oid,
			OID_LENGTH(ieee8021BridgeEvbSysEcpAckTimer_oid),
			HANDLER_CAN_RWRITE));

	netsnmp_register_scalar(
		netsnmp_create_handler_registration(
			"ieee8021BridgeEvbSysEcpMaxRetries",
			handle_ieee8021BridgeEvbSysEcpMaxRetries,
			ieee8021BridgeEvbSysEcpMaxRetries_oid,
			OID_LENGTH(ieee8021BridgeEvbSysEcpMaxRetries_oid),
			HANDLER_CAN_RWRITE));

	netsnmp_register_scalar(
		netsnmp_create_handler_registration(
			"ieee8021BridgeEvbSysVdpDfltRsrcWaitDelay",
			handle_ieee8021BridgeEvbSysVdpDfltRsrcWaitDelay,
			ieee8021BridgeEvbSysVdpDfltRsrcWaitDelay_oid,
			OID_LENGTH(ieee8021BridgeEvbSysVdpDfltRsrcWaitDelay_oid),
			HANDLER_CAN_RWRITE));

	netsnmp_register_scalar(
		netsnmp_create_handler_registration(
			"ieee8021BridgeEvbSysVdpDfltReinitKeepAlive",
			handle_ieee8021BridgeEvbSysVdpDfltReinitKeepAlive,
			ieee8021BridgeEvbSysVdpDfltReinitKeepAlive_oid,
			OID_LENGTH(ieee8021BridgeEvbSysVdpDfltReinitKeepAlive_oid),
			HANDLER_CAN_RWRITE));
}

/* SNMP handlers are never called for a GETNEXT as an "instance" the
 * infastructure handles this case. Further instance handler only hands us
 * one request at a time, so we don't need to loop over a list of requests;
 * we'll only get one.
 */

int handle_ieee8021BridgeEvbSysType(
	UNUSED netsnmp_mib_handler		*handler,
	UNUSED netsnmp_handler_registration	*reginfo,
	netsnmp_agent_request_info		*reqinfo,
	netsnmp_request_info			*requests)
{
	ieee8021_evb_sys_type = get_evbsystype();

	switch(reqinfo->mode) {
        case MODE_GET:
		snmp_set_var_typed_value(
			requests->requestvb, ASN_INTEGER,
			&ieee8021_evb_sys_type,
			sizeof(ieee8021_evb_sys_type));
		break;
        default:
		snmp_log(LOG_ERR, "unknown mode (%d) ", reqinfo->mode);
		snmp_log(LOG_ERR, "in handle_ieee8021BridgeEvbSysType\n");
		return SNMP_ERR_GENERR;
	}

	return SNMP_ERR_NOERROR;
}

int handle_ieee8021BridgeEvbSysNumExternalPorts(
	UNUSED netsnmp_mib_handler		*handler,
	UNUSED netsnmp_handler_registration	*reginfo,
	netsnmp_agent_request_info		*reqinfo,
	netsnmp_request_info			*requests)
{
	switch(reqinfo->mode) {
	case MODE_GET:
		snmp_set_var_typed_value(
			requests->requestvb, ASN_UNSIGNED,
			&ieee8021BridgeEvbSysNumExternalPorts,
			sizeof(ieee8021BridgeEvbSysNumExternalPorts));
		break;
	default:
		snmp_log(LOG_ERR, "unknown mode (%d) ", reqinfo->mode);
		snmp_log(LOG_ERR, "in handle_ieee8021BridgeEvbSys\n");
		snmp_log(LOG_ERR, "NumExternalPorts\n");
		return SNMP_ERR_GENERR;
	}

	return SNMP_ERR_NOERROR;
}

int handle_ieee8021BridgeEvbSysEvbLldpTxEnable(
	UNUSED netsnmp_mib_handler		*handler,
	UNUSED netsnmp_handler_registration	*reginfo,
	netsnmp_agent_request_info		*reqinfo,
	netsnmp_request_info			*requests)
{
	switch(reqinfo->mode) {
        case MODE_GET:
		snmp_set_var_typed_value(
			requests->requestvb, ASN_INTEGER,
			&ieee8021BridgeEvbSysEvbLldpTxEnable,
			sizeof(ieee8021BridgeEvbSysEvbLldpTxEnable));
		break;
	default:
		snmp_log(LOG_ERR, "unknown mode (%d) ", reqinfo->mode);
		snmp_log(LOG_ERR, "in handle_ieee8021BridgeEvbSys\n");
		snmp_log(LOG_ERR, "EvbLldpTxEnable\n");
		return SNMP_ERR_GENERR;
	}
	return SNMP_ERR_NOERROR;
}

int handle_ieee8021BridgeEvbSysEvbLldpManual(
	UNUSED netsnmp_mib_handler		*handler,
	UNUSED netsnmp_handler_registration	*reginfo,
	netsnmp_agent_request_info		*reqinfo,
	netsnmp_request_info			*requests)
{
	switch(reqinfo->mode) {
	case MODE_GET:
		snmp_set_var_typed_value(
			requests->requestvb, ASN_INTEGER,
			&ieee8021BridgeEvbSysEvbLldpManual,
			sizeof(ieee8021BridgeEvbSysEvbLldpManual));
		break;
        default:
		snmp_log(LOG_ERR, "unknown mode (%d) ", reqinfo->mode);
		snmp_log(LOG_ERR, "in handle_ieee8021BridgeEvbSys");
		snmp_log(LOG_ERR, "EvbLldpManual");
		return SNMP_ERR_GENERR;
	}
	return SNMP_ERR_NOERROR;
}

int handle_ieee8021BridgeEvbSysEvbLldpGidCapable(
	UNUSED netsnmp_mib_handler		*handler,
	UNUSED netsnmp_handler_registration	*reginfo,
	netsnmp_agent_request_info		*reqinfo,
	netsnmp_request_info			*requests)
{
	switch(reqinfo->mode) {
        case MODE_GET:
		snmp_set_var_typed_value(
			requests->requestvb, ASN_INTEGER,
			&ieee8021BridgeEvbSysEvbLldpGidCapable,
			sizeof(ieee8021BridgeEvbSysEvbLldpGidCapable));
		break;
	default:
		snmp_log(LOG_ERR, "unknown mode (%d) ", reqinfo->mode);
		snmp_log(LOG_ERR, "in handle_ieee8021BridgeEvbSys");
		snmp_log(LOG_ERR, "EvbLldpGidCapable");
		return SNMP_ERR_GENERR;
	}
	return SNMP_ERR_NOERROR;
}

int handle_ieee8021BridgeEvbSysEcpAckTimer(
	UNUSED netsnmp_mib_handler		*handler,
	UNUSED netsnmp_handler_registration	*reginfo,
	netsnmp_agent_request_info		*reqinfo,
	netsnmp_request_info			*requests)
{
	switch(reqinfo->mode) {
	case MODE_GET:
		snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
					 &ieee8021BridgeEvbECPACkTimer,
					 sizeof(ieee8021BridgeEvbECPACkTimer));
		break;
	default:
		snmp_log(LOG_ERR, "unknown mode (%d) ", reqinfo->mode);
		snmp_log(LOG_ERR, "in handle_ieee8021BridgeEvbSys");
		snmp_log(LOG_ERR, "EcpAckTimer");
		return SNMP_ERR_GENERR;
	}
	return SNMP_ERR_NOERROR;
}

int handle_ieee8021BridgeEvbSysEcpMaxRetries(
	UNUSED netsnmp_mib_handler		*handler,
	UNUSED netsnmp_handler_registration	*reginfo,
	netsnmp_agent_request_info		*reqinfo,
	netsnmp_request_info			*requests)
{
	switch(reqinfo->mode) {
	case MODE_GET:
		snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
					 &ieee8021BridgeEvbECPMaxRetires,
					 sizeof(ieee8021BridgeEvbECPMaxRetires));
		break;
	default:
		snmp_log(LOG_ERR, "unknown mode (%d) ", reqinfo->mode);
		snmp_log(LOG_ERR, "in handle_ieee8021BridgeEvbSys");
		snmp_log(LOG_ERR, "EcpMaxRetries");
		return SNMP_ERR_GENERR;
	}
	return SNMP_ERR_NOERROR;
}

int handle_ieee8021BridgeEvbSysVdpDfltRsrcWaitDelay(
	UNUSED netsnmp_mib_handler		*handler,
	UNUSED netsnmp_handler_registration	*reginfo,
	netsnmp_agent_request_info		*reqinfo,
	netsnmp_request_info			*requests)
{
	switch(reqinfo->mode) {
	case MODE_GET:
		snmp_set_var_typed_value(
			requests->requestvb, ASN_INTEGER,
			&ieee8021BridgeEvbSysVdpDfltRsrcWaitDelay,
			sizeof(ieee8021BridgeEvbSysVdpDfltRsrcWaitDelay));
		break;
	default:
		snmp_log(LOG_ERR, "unknown mode (%d) ", reqinfo->mode);
		snmp_log(LOG_ERR, "in handle_ieee8021BridgeEvbSys");
		snmp_log(LOG_ERR, "VdpDfltRsrcWaitDelay\n");
		return SNMP_ERR_GENERR;
	}
	return SNMP_ERR_NOERROR;
}

int handle_ieee8021BridgeEvbSysVdpDfltReinitKeepAlive(
	UNUSED netsnmp_mib_handler		*handler,
	UNUSED netsnmp_handler_registration	*reginfo,
	netsnmp_agent_request_info		*reqinfo,
	netsnmp_request_info			*requests)
{
	switch(reqinfo->mode) {
	case MODE_GET:
		snmp_set_var_typed_value(
			requests->requestvb, ASN_INTEGER,
			&ieee8021BridgeEvbSysVdpDfltReinitKeepAlive,
			sizeof(ieee8021BridgeEvbSysVdpDfltReinitKeepAlive));
		break;
	default:
		snmp_log(LOG_ERR, "unknown mode (%d) in ", reqinfo->mode);
		snmp_log(LOG_ERR, "handle_ieee8021BridgeEvbSys");
		snmp_log(LOG_ERR, "VdpDfltReinitKeepAlive\n");

		return SNMP_ERR_GENERR;
	}
	return SNMP_ERR_NOERROR;
}
