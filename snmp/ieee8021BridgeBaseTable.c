/******************************************************************************

  LLDP Agent Daemon (LLDPAD) Software
  Copyright(c) 2012 IBM Corp.
  Copyright(c) 2012 Intel Corporation.

  Author(s): John Fastabend <john.r.fastabend at intel.com>
  Author(s): Mijo Safradin <mijo at linux.vnet.ibm.com>

  This program is free software; you can redistribute it and/or modify it
  under the terms and conditions of the GNU General Public License,
  version 2, as published by the Free Software Foundation.

  This program is distributed in the hope it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  more details.

  You should have received a copy of the GNU General Public License along with
  this program; if not, write to the Free Software Foundation, Inc.,
  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.

  The full GNU General Public License is included in this distribution in
  the file called "COPYING".

  Contact Information:
  open-lldp Mailing List <lldp-devel at open-lldp.org>

  Note: this file originally auto-generated by mib2c using
        version : 5.7.1
******************************************************************************/

#include "snmp/snmp_agent.h"

/** Initializes the ieee8021BridgeBaseTable module */
void
init_ieee8021BridgeBaseTable(void)
{
	/* initialize supported tables */
	initialize_table_ieee8021BridgeBaseTable();
}

/** Create new bridge base table entry
 */
netsnmp_tdata_row *ieee8021BridgeBaseTable_createEntry(
					netsnmp_tdata * table_data,
					u_long ieee8021BridgeBaseComponentId,
					struct ieee_bridge_mib_list *list)
{
	netsnmp_tdata_row *row;
	struct ieee8021BridgeBaseTable_entry *entry;

	entry = SNMP_MALLOC_TYPEDEF(struct ieee8021BridgeBaseTable_entry);
	if (!entry)
		return NULL;

	row = netsnmp_tdata_create_row();
	if (!row) {
		SNMP_FREE(entry);
		return NULL;
	}

	entry->ieee8021BridgeBaseComponentId = ieee8021BridgeBaseComponentId;
	memset(entry->ieee8021BridgeBaseBridgeAddress, 0,
	       sizeof(entry->ieee8021BridgeBaseBridgeAddress));
	memcpy(entry->ieee8021BridgeBaseBridgeAddress, list->mac, 6);
	entry->ieee8021BridgeBaseBridgeAddress_len = 6;
	entry->ieee8021BridgeBaseNumPorts = list->num_ports;
	entry->ieee8021BridgeBaseRowStatus = 1;

	row->data = entry;

	list->entry = entry;
	list->row = row;

	netsnmp_tdata_row_add_index(
		row, ASN_UNSIGNED,
		&(entry->ieee8021BridgeBaseComponentId),
		sizeof(entry->ieee8021BridgeBaseComponentId));
	if (table_data)
		netsnmp_tdata_add_row(table_data, row);
	else {
		SNMP_FREE(entry);
		return NULL;
	}

	return row;
}

/** Initialize the ieee8021BridgeBaseTable table by defining
 *  its contents and how it's structured
 */
void
initialize_table_ieee8021BridgeBaseTable(void)
{
	const oid ieee8021BridgeBaseTable_oid[] = {
			1, 3, 111, 2, 802, 1, 1, 2, 1, 1, 1};
	const size_t ieee8021BridgeBaseTable_oid_len =
		OID_LENGTH(ieee8021BridgeBaseTable_oid);
	netsnmp_handler_registration	*reg;
	netsnmp_tdata			*table_data;
	netsnmp_table_registration_info	*table_info;
	struct ieee_bridge_mib_list	*entry;

	DEBUGMSGTL(("ieee8021BridgeBaseTable:init",
		    "initializing table ieee8021BridgeBaseTable\n"));

	reg = netsnmp_create_handler_registration(
		"ieee8021BridgeBaseTable", ieee8021BridgeBaseTable_handler,
		ieee8021BridgeBaseTable_oid, ieee8021BridgeBaseTable_oid_len,
		HANDLER_CAN_RWRITE);

	table_data = netsnmp_tdata_create_table("ieee8021BridgeBaseTable", 0);
	if (table_data == NULL)
		snmp_log(LOG_ERR,"error creating tdata table for ieee8021BridgeBaseTable\n");

	table_data_ieee8021BridgeBaseTable = table_data;
	table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
	if (table_info == NULL)
		snmp_log(LOG_ERR,"error creating table info for ieee8021BridgeBaseTable\n");

	netsnmp_table_helper_add_indexes(
		table_info,
		ASN_UNSIGNED,  /* index: ieee8021BridgeBaseComponentId */
		0);

	table_info->min_column = COLUMN_IEEE8021BRIDGEBASEBRIDGEADDRESS;
	table_info->max_column = COLUMN_IEEE8021BRIDGEBASEROWSTATUS;

	netsnmp_tdata_register(reg, table_data, table_info);

	/* Initialise the contents of the table here */
	LIST_FOREACH(entry, &ieee_brl_head, entries) {
		ieee8021BridgeBaseTable_createEntry(table_data, entry->compid, entry);
	}
}

/* remove a row from the table */
void
ieee8021BridgeBaseTable_removeEntry(netsnmp_tdata *table_data,
				    netsnmp_tdata_row *row)
{
	struct ieee8021BridgeBaseTable_entry *entry;

	if (!row)
		return;	/* Nothing to remove */

	entry = (struct ieee8021BridgeBaseTable_entry *)row->data;
	SNMP_FREE(entry);

	if (table_data)
		netsnmp_tdata_remove_and_delete_row(table_data, row);
	else
		netsnmp_tdata_delete_row(row);
}

/** handles requests for the ieee8021BridgeBaseTable table */
int
ieee8021BridgeBaseTable_handler(
	UNUSED netsnmp_mib_handler		*handler,
	UNUSED netsnmp_handler_registration	*reginfo,
	netsnmp_agent_request_info		*reqinfo,
	netsnmp_request_info			*requests)
{
	netsnmp_request_info		*request;
	netsnmp_table_request_info	*table_info;
	netsnmp_tdata			*table_data;
	netsnmp_tdata_row		*table_row;
	struct ieee8021BridgeBaseTable_entry *table_entry;
	int				ret;

	DEBUGMSGTL(("ieee8021BridgeBaseTable:handler",
		    "Processing request (%d)\n", reqinfo->mode));

	switch (reqinfo->mode) {
	case MODE_GET:
		for (request = requests; request; request = request->next) {
			table_entry = (struct ieee8021BridgeBaseTable_entry *)
						netsnmp_tdata_extract_entry(request);
			table_info = netsnmp_extract_table_info(request);

			switch (table_info->colnum) {
			case COLUMN_IEEE8021BRIDGEBASEBRIDGEADDRESS:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
					continue;
				}

				snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
							 table_entry->ieee8021BridgeBaseBridgeAddress,
							 table_entry->ieee8021BridgeBaseBridgeAddress_len);
				break;
			case COLUMN_IEEE8021BRIDGEBASENUMPORTS:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
					continue;
				}

				snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
							   table_entry->ieee8021BridgeBaseNumPorts);
                		break;
            		case COLUMN_IEEE8021BRIDGEBASECOMPONENTTYPE:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
					continue;
				}

				snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
							   table_entry->ieee8021BridgeBaseComponentType);
				break;
			case COLUMN_IEEE8021BRIDGEBASEDEVICECAPABILITIES:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
                    			continue;
				}
				snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
						table_entry->ieee8021BridgeBaseDeviceCapabilities,
						table_entry->ieee8021BridgeBaseDeviceCapabilities_len);
				break;
			case COLUMN_IEEE8021BRIDGEBASETRAFFICCLASSESENABLED:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
					table_entry->ieee8021BridgeBaseTrafficClassesEnabled);
				break;
			case COLUMN_IEEE8021BRIDGEBASEMMRPENABLEDSTATUS:
				if (!table_entry) {
					netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
					table_entry->ieee8021BridgeBaseMmrpEnabledStatus);
				break;

			case COLUMN_IEEE8021BRIDGEBASEROWSTATUS:
				if (!table_entry) {
                    			netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
					continue;
				}
				snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
					table_entry->ieee8021BridgeBaseRowStatus);
				break;
			default:
				netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
				break;
            		}
        	}
        	break;
	case MODE_SET_RESERVE1:
        	for (request=requests; request; request=request->next) {
			table_entry = (struct ieee8021BridgeBaseTable_entry *)
						netsnmp_tdata_extract_entry(request);
			table_info = netsnmp_extract_table_info(request);
			switch (table_info->colnum) {
			case COLUMN_IEEE8021BRIDGEBASEBRIDGEADDRESS:
				ret = netsnmp_check_vb_type_and_max_size(request->requestvb,
									 ASN_OCTET_STR,
									 sizeof(table_entry->ieee8021BridgeBaseBridgeAddress));
				if (ret != SNMP_ERR_NOERROR) {
					netsnmp_set_request_error(reqinfo, request, ret);
					return SNMP_ERR_NOERROR;
				}
				break;
			case COLUMN_IEEE8021BRIDGEBASECOMPONENTTYPE:
				ret = netsnmp_check_vb_int( request->requestvb );
				if (ret != SNMP_ERR_NOERROR) {
					netsnmp_set_request_error(reqinfo, request, ret);
					return SNMP_ERR_NOERROR;
				}
				break;
			case COLUMN_IEEE8021BRIDGEBASEDEVICECAPABILITIES:
				ret = netsnmp_check_vb_type_and_max_size(request->requestvb,
									 ASN_OCTET_STR,
									 sizeof(table_entry->ieee8021BridgeBaseDeviceCapabilities));
				if (ret != SNMP_ERR_NOERROR) {
					netsnmp_set_request_error(reqinfo, request, ret);
					return SNMP_ERR_NOERROR;
				}
				break;
			case COLUMN_IEEE8021BRIDGEBASETRAFFICCLASSESENABLED:
				ret = netsnmp_check_vb_int(request->requestvb);
				if (ret != SNMP_ERR_NOERROR) {
					netsnmp_set_request_error(reqinfo, request, ret);
					return SNMP_ERR_NOERROR;
				}
				break;
			case COLUMN_IEEE8021BRIDGEBASEMMRPENABLEDSTATUS:
				ret = netsnmp_check_vb_int(request->requestvb);
				if (ret != SNMP_ERR_NOERROR) {
					netsnmp_set_request_error(reqinfo, request, ret);
					return SNMP_ERR_NOERROR;
				}
				break;
			case COLUMN_IEEE8021BRIDGEBASEROWSTATUS:
				ret = netsnmp_check_vb_rowstatus(request->requestvb,
								 (table_entry ? RS_ACTIVE : RS_NONEXISTENT));
				if (ret != SNMP_ERR_NOERROR) {
					netsnmp_set_request_error(reqinfo, request, ret);
					return SNMP_ERR_NOERROR;
				}
				break;
			default:
				netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE);
				return SNMP_ERR_NOERROR;
            		}
		}
		break;
	case MODE_SET_RESERVE2:
		for (request=requests; request; request=request->next) {
			table_row  = netsnmp_tdata_extract_row(request);
			table_data = netsnmp_tdata_extract_table(request);
			table_info = netsnmp_extract_table_info(request);

			switch (table_info->colnum) {
			case COLUMN_IEEE8021BRIDGEBASEROWSTATUS:
				switch (*request->requestvb->val.integer) {
				case RS_CREATEANDGO:
				case RS_CREATEANDWAIT:
					table_row = ieee8021BridgeBaseTable_createEntry(table_data,
											*table_info->indexes->val.integer,
											NULL);

					if (table_row) {
						netsnmp_insert_tdata_row(request, table_row );
					} else {
						netsnmp_set_request_error(reqinfo, request,
                                                   			  SNMP_ERR_RESOURCEUNAVAILABLE );
						return SNMP_ERR_NOERROR;
					}
				}
			}

		}
		break;
	case MODE_SET_FREE:
		for (request=requests; request; request=request->next) {
			table_entry = (struct ieee8021BridgeBaseTable_entry *)
						netsnmp_tdata_extract_entry(request);
			table_row  = netsnmp_tdata_extract_row(request);
			table_data = netsnmp_tdata_extract_table(request);
			table_info = netsnmp_extract_table_info(request);

			switch (table_info->colnum) {
			case COLUMN_IEEE8021BRIDGEBASEROWSTATUS:
				switch (*request->requestvb->val.integer) {
				case RS_CREATEANDGO:
				case RS_CREATEANDWAIT:
					if (table_entry && !table_entry->valid)
						ieee8021BridgeBaseTable_removeEntry(table_data, table_row );
				}
			}
		}
		break;
	case MODE_SET_ACTION:
		for (request=requests; request; request=request->next) {
			table_entry = (struct ieee8021BridgeBaseTable_entry *)
						netsnmp_tdata_extract_entry(request);
			table_info = netsnmp_extract_table_info(request);

			switch (table_info->colnum) {
			case COLUMN_IEEE8021BRIDGEBASEBRIDGEADDRESS:
				memcpy(table_entry->old_ieee8021BridgeBaseBridgeAddress,
		       		       table_entry->ieee8021BridgeBaseBridgeAddress,
				sizeof(table_entry->ieee8021BridgeBaseBridgeAddress));
			 	table_entry->old_ieee8021BridgeBaseBridgeAddress_len =
					table_entry->ieee8021BridgeBaseBridgeAddress_len;
				memset(table_entry->ieee8021BridgeBaseBridgeAddress, 0,
		       		       sizeof(table_entry->ieee8021BridgeBaseBridgeAddress));
				memcpy(table_entry->ieee8021BridgeBaseBridgeAddress,
				       request->requestvb->val.string,
				       request->requestvb->val_len);
				table_entry->ieee8021BridgeBaseBridgeAddress_len =
					request->requestvb->val_len;
				break;
			case COLUMN_IEEE8021BRIDGEBASECOMPONENTTYPE:
				table_entry->old_ieee8021BridgeBaseComponentType = table_entry->ieee8021BridgeBaseComponentType;
				table_entry->ieee8021BridgeBaseComponentType     = *request->requestvb->val.integer;
				break;
			case COLUMN_IEEE8021BRIDGEBASEDEVICECAPABILITIES:
				memcpy(table_entry->old_ieee8021BridgeBaseDeviceCapabilities,
				       table_entry->ieee8021BridgeBaseDeviceCapabilities,
				       sizeof(table_entry->ieee8021BridgeBaseDeviceCapabilities));
				table_entry->old_ieee8021BridgeBaseDeviceCapabilities_len =
					table_entry->ieee8021BridgeBaseDeviceCapabilities_len;
				memset(table_entry->ieee8021BridgeBaseDeviceCapabilities, 0,
				       sizeof(table_entry->ieee8021BridgeBaseDeviceCapabilities));
				memcpy(table_entry->ieee8021BridgeBaseDeviceCapabilities,
				       request->requestvb->val.string,
				       request->requestvb->val_len);
				table_entry->ieee8021BridgeBaseDeviceCapabilities_len =
					request->requestvb->val_len;
				break;
			case COLUMN_IEEE8021BRIDGEBASETRAFFICCLASSESENABLED:
				table_entry->old_ieee8021BridgeBaseTrafficClassesEnabled = table_entry->ieee8021BridgeBaseTrafficClassesEnabled;
				table_entry->ieee8021BridgeBaseTrafficClassesEnabled     = *request->requestvb->val.integer;
				break;
			case COLUMN_IEEE8021BRIDGEBASEMMRPENABLEDSTATUS:
				table_entry->old_ieee8021BridgeBaseMmrpEnabledStatus = table_entry->ieee8021BridgeBaseMmrpEnabledStatus;
				table_entry->ieee8021BridgeBaseMmrpEnabledStatus     = *request->requestvb->val.integer;
				break;
			}
		}
		/* Check the internal consistency of an active row */
		for (request=requests; request; request=request->next) {
			table_entry = (struct ieee8021BridgeBaseTable_entry *)
						netsnmp_tdata_extract_entry(request);
			table_info = netsnmp_extract_table_info(request);
            		switch (table_info->colnum) {
			case COLUMN_IEEE8021BRIDGEBASEROWSTATUS:
				switch (*request->requestvb->val.integer) {
				case RS_ACTIVE:
				case RS_CREATEANDGO:
					netsnmp_set_request_error(reqinfo, request,
								  SNMP_ERR_INCONSISTENTVALUE);
					return SNMP_ERR_NOERROR;
				}
			}
        	}
		break;
	case MODE_SET_UNDO:
		for (request=requests; request; request=request->next) {
			table_entry = (struct ieee8021BridgeBaseTable_entry *)
						netsnmp_tdata_extract_entry(request);
			table_row  = netsnmp_tdata_extract_row(request);
			table_data = netsnmp_tdata_extract_table(request);
			table_info = netsnmp_extract_table_info(request);

			switch (table_info->colnum) {
			case COLUMN_IEEE8021BRIDGEBASEBRIDGEADDRESS:
				memcpy(table_entry->ieee8021BridgeBaseBridgeAddress,
				       table_entry->old_ieee8021BridgeBaseBridgeAddress,
				       sizeof(table_entry->ieee8021BridgeBaseBridgeAddress));
				memset(table_entry->old_ieee8021BridgeBaseBridgeAddress, 0,
				       sizeof(table_entry->ieee8021BridgeBaseBridgeAddress));
				table_entry->ieee8021BridgeBaseBridgeAddress_len =
						table_entry->old_ieee8021BridgeBaseBridgeAddress_len;
				break;

			case COLUMN_IEEE8021BRIDGEBASECOMPONENTTYPE:
				table_entry->ieee8021BridgeBaseComponentType = table_entry->old_ieee8021BridgeBaseComponentType;
				table_entry->old_ieee8021BridgeBaseComponentType = 0;
				break;
			case COLUMN_IEEE8021BRIDGEBASEDEVICECAPABILITIES:
				memcpy(table_entry->ieee8021BridgeBaseDeviceCapabilities,
				       table_entry->old_ieee8021BridgeBaseDeviceCapabilities,
				       sizeof(table_entry->ieee8021BridgeBaseDeviceCapabilities));
				memset(table_entry->old_ieee8021BridgeBaseDeviceCapabilities, 0,
				       sizeof(table_entry->ieee8021BridgeBaseDeviceCapabilities));
				table_entry->ieee8021BridgeBaseDeviceCapabilities_len =
						table_entry->old_ieee8021BridgeBaseDeviceCapabilities_len;
				break;
			case COLUMN_IEEE8021BRIDGEBASETRAFFICCLASSESENABLED:
				table_entry->ieee8021BridgeBaseTrafficClassesEnabled = table_entry->old_ieee8021BridgeBaseTrafficClassesEnabled;
				table_entry->old_ieee8021BridgeBaseTrafficClassesEnabled = 0;
				break;
			case COLUMN_IEEE8021BRIDGEBASEMMRPENABLEDSTATUS:
				table_entry->ieee8021BridgeBaseMmrpEnabledStatus = table_entry->old_ieee8021BridgeBaseMmrpEnabledStatus;
				table_entry->old_ieee8021BridgeBaseMmrpEnabledStatus = 0;
				break;
			case COLUMN_IEEE8021BRIDGEBASEROWSTATUS:
				switch (*request->requestvb->val.integer) {
				case RS_CREATEANDGO:
				case RS_CREATEANDWAIT:
					if (table_entry && !table_entry->valid)
						ieee8021BridgeBaseTable_removeEntry(table_data, table_row );
                		}
				break;
			}
		}
		break;
	case MODE_SET_COMMIT:
		for (request=requests; request; request=request->next) {
			table_entry = (struct ieee8021BridgeBaseTable_entry *)
						netsnmp_tdata_extract_entry(request);
			table_row = netsnmp_tdata_extract_row(request);
			table_data = netsnmp_tdata_extract_table(request);
			table_info = netsnmp_extract_table_info(request);

			switch (table_info->colnum) {
			case COLUMN_IEEE8021BRIDGEBASEROWSTATUS:
				switch (*request->requestvb->val.integer) {
				case RS_CREATEANDGO:
					table_entry->valid = 1;
				/* Fall-through */
				case RS_ACTIVE:
					table_entry->ieee8021BridgeBaseRowStatus = RS_ACTIVE;
					break;
				case RS_CREATEANDWAIT:
					table_entry->valid = 1;
				/* Fall-through */
				case RS_NOTINSERVICE:
					table_entry->ieee8021BridgeBaseRowStatus = RS_NOTINSERVICE;
					break;
				case RS_DESTROY:
					ieee8021BridgeBaseTable_removeEntry(table_data, table_row);
				}
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}
